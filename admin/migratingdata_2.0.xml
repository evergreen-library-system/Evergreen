<?xml version='1.0' encoding='UTF-8'?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude"
	    xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:id="migratingdata" >
	<info>		
	<title>Migrating Data</title>
		<abstract>
			<para>Migrating data into Evergreen can be one of the most daunting tasks for an administrator. This chapter will explain some procedures to help to migrate 
			bibliographic records, copies and patrons into the Evergreen system. This chapter requires advanced ILS Administration experience, knowledge of Evergreen data structures, 
			as well as knowledge of how to export data from your current system or access to data export files from your current system.</para>
        	</abstract>
	</info>    
	<section xml:id="migratingbibrecords">
		<title>Migrating Bibliographic Records</title>
		<indexterm><primary>migrating</primary><secondary>importing bibliographic records</secondary></indexterm>
		<para>
		One of the most important and challenging  tasks is migrating your bibliographic records to a new system. The procedure may be different depending on the system from which you 
		are migrating  and the content of the marc records exported from the existing system. The procedures in this section deal with the process once the data from the existing system 
		is exported into marc records. It does not cover exporting data from your existing non-Evergreen system.</para>
		<para>Several tools for importing bibliographic records into Evergreen can be found in the Evergreen installation folder 
		(<filename class="directory">/home/opensrf/Evergreen-ILS-1.6.1.6/Open-ILS/src/extras/import/</filename> ) and are also available from the Evergreen repository 
		(<link xl:href="http://svn.open-ils.org/trac/ILS/browser/branches/rel_1_6_1/Open-ILS/src/extras/import" xl:title="import scripts - Evergreen repository">
		http://svn.open-ils.org/trac/ILS/browser/branches/rel_1_6_1/Open-ILS/src/extras/import</link>).</para> 
		<simplesect>
			<title>Converting MARC records to Evergreen BRE JSON format</title>
			<indexterm><primary>BRE JSON</primary></indexterm>
			<para>If you are starting with MARC records from your existing system or another source, use the marc2bre.pl script to create the JSON representation of a bibliographic 
			record entry (hence bre) in Evergreen. <filename>marc2bre.pl</filename> can perform the following functions:</para>
     			<itemizedlist> 
				<listitem><para>Converts <systemitem>MARC-8</systemitem> encoded records to <systemitem>UTF-8</systemitem> encoding</para></listitem>
      				<listitem><para>Converts <systemitem>MARC21</systemitem> to <systemitem>MARCXML21</systemitem></para></listitem>
     				<listitem><para>Select the unique record number field (common choices are '035' or '001'; check your records as you might be surprised how a supposedly unique field 
				actually has duplicates, though marc2bre.pl will select a unique identifier for subsequent duplicates)</para></listitem>
     				<listitem><para>Extracts certain pertinent fields for indexing and display purposes (along with the complete MARCXML21 record)</para></listitem>
     				<listitem><para>Sets the ID number of the first record from this batch to be imported into the biblio.record_entry table (hint - run the following 
				<systemitem>SQL</systemitem> to determine what this number should be to avoid conflicts:</para>
<screen>
<userinput>psql -U postgres evergreen</userinput>
<userinput> # SELECT MAX(id)+1 FROM biblio.record_entry;</userinput>
</screen>
			</listitem>
            		<listitem>
				<para>If you are processing multiple sets of MARC records with <command>marc2bre.pl</command> before loading the records into the database, you will need to keep track 
				of the starting ID number for each subsequent batch of records that you are importing. For example, if you are processing three files of MARC records with 10000 
				records each into a clean database, you would use <option>–startid 1</option>, <option>–startid 10001</option>, and <option>–startid 20001</option> 
				parameters for each respective file.</para>
			</listitem>
      			<listitem>
				<para>Ignore <quote>trash</quote> fields that you do not want to retain in Evergreen</para>
			</listitem>
			<listitem>
				<para>If you use <filename>marc2bre.pl</filename> to convert your MARC records from the <systemitem>MARC-8</systemitem> encoding to the UTF-8 encoding, it relies
				 on the <systemitem>MARC::Charset Perl</systemitem> module to complete the conversion. When importing a large set of items, you can speed up the process by using a 
				utility like <systemitem>marc4j</systemitem> or <systemitem>marcdumper</systemitem> to convert the records 
				to <systemitem>MARC21XML</systemitem> and <systemitem>UTF-8</systemitem> before running them through <command>marc2bre.pl</command> with the 
				<option>–marctype=XML</option> flag to tell <command>marc2bre.pl</command> that the records are already in <systemitem>MARC21XML</systemitem> format with 
				the <systemitem>UTF-8 </systemitem>encoding. If you take this approach, due to a current limitation of <systemitem>MARC::File::XML</systemitem> you have to do a 
				horrible thing and ensure that there are no namespace prefixes in front of the element names. <filename>marc2bre.pl</filename> cannot parse the following 
				example:</para>

<programlisting language="xml">
<![CDATA[

<?xml version="1.0" encoding="UTF-8" ?>
<marc:collection xmlns:marc="http://www.loc.gov/MARC21/slim" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:schemaLocation="http://www.loc.gov/MARC/slim 
http://www.loc.gov/standards/marcxml/schema/MARC21slim.xsd">
  <marc:record>
    <marc:leader>00677nam a2200193 a 4500</marc:leader>
    <marc:controlfield tag="001">H01-0000844</marc:controlfield>
    <marc:controlfield tag="007">t </marc:controlfield>
    <marc:controlfield tag="008">060420s1950    xx            000 u fre d</marc:controlfield>
    <marc:datafield tag="040" ind1=" " ind2=" ">
      <marc:subfield code="a">CaOHCU</marc:subfield>
      <marc:subfield code="b">fre</marc:subfield>
    </marc:datafield>
...
]]>;
</programlisting>
			
			<para>But marc2bre.pl can parse the same example with the namespace prefixes removed:</para>
<programlisting language="xml">
<![CDATA[
<?xml version="1.0" encoding="UTF-8" ?>
<collection xmlns:marc="http://www.loc.gov/MARC21/slim" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:schemaLocation="http://www.loc.gov/MARC/slim 
http://www.loc.gov/standards/marcxml/schema/MARC21slim.xsd">
  <record>
    <leader>00677nam a2200193 a 4500</leader>
    <controlfield tag="001">H01-0000844</controlfield>
    <controlfield tag="007">t </controlfield>
    <controlfield tag="008">060420s1950    xx            000 u fre d</controlfield>
    <datafield tag="040" ind1=" " ind2=" ">
      <subfield code="a">CaOHCU</subfield>
      <subfield code="b">fre</subfield>
    </datafield>
...
]]>;
</programlisting>
				</listitem>
			</itemizedlist>
		</simplesect>
		<simplesect>
			<title>Converting Records for Import into PostgreSQL</title>
			<indexterm><primary>migrating</primary><secondary>import into PostgreSQL</secondary></indexterm>
			<para>Once you have your records in Open-ILS <systemitem>JSON</systemitem> ingest format, you then need to use <command>pg_loader.pl</command> to convert these records into a 
			set of <systemitem>SQL</systemitem> statements that you can use to 
			load the records into PostgreSQL. The <option>–order</option> and <option>–autoprimary</option> command line options (bre, mrd, mfr, etc) map to class IDs defined in 
			<filename>/openils/conf/fm_IDL.xml</filename>.</para>
		</simplesect>		
		<simplesect>
			<title>Adding Metarecords to the Database</title>
			<indexterm><primary>migrating</primary><secondary>adding metarecords</secondary></indexterm>
			<para>One you have loaded the records into PostgreSQL, you can create metarecord entries in the <link linkend="metabib.table.metarecord">metabib.metarecord</link> table by 				running the following <systemitem>SQL</systemitem>:</para>
<screen>
<userinput>psql evergreen</userinput>
<userinput># \i /home/opensrf/Evergreen-ILS-1.6*/src/extras/import/quick_metarecord_map.sql</userinput>
</screen>
			<para>Metarecords are required to place holds on items, among other actions.</para>
		</simplesect>	
	</section>



<section xml:id="migrating_records_using_migration_tools">
		<title>Migrating Bibliographic Records Using the ESI Migration Tools</title>
		<indexterm><primary>migrating</primary><secondary>bibliograohic records</secondary></indexterm>	
		<para>The following procedure explains how to migrate bibliographic records from marc records into Evergreen. This is a general guide and will need to be adjusted for your 
		specific environment. It does not cover exporting records from specific proprietary ILS 
		systems. For assistance with exporting records from your current system please refer to the manuals for your system or you might try to ask for help from the 
		<link linkend="more_info">Evergreen community</link>.</para>
		
		<procedure>
			<step>
				<para>Download the Evergreen <link xl:href="http://git.esilibrary.com/?p=migration-tools.git;a=summary" 
				xl:title="Equinox migration utilities">migration utilities</link> from the git repository.</para>
				<para>Use the command <command>git clone git://git.esilibrary.com/git/migration-tools.git</command> to clone the migration tools.</para>
				 <para>Install the migration tools:</para>
<screen>
<userinput>
<![CDATA[
cd migration-tools/Equinox-Migration
perl Makefile.PL
make
make test
make install
]]>
</userinput>
</screen>
</step>	
			<step>
				<para>Add environmental variables for migration and import tools. These paths must point to:
					<itemizedlist>
						<listitem>the import perl scripts bundled with Evergreen </listitem>
						<listitem>the folder where you extracted the migration tools</listitem>
						<listitem>the location of the Equinox-Migration perl modules </listitem>
						<listitem>the location of the Evergreen perl modules (e.g. perl5)</listitem>
					</itemizedlist>
				</para> 
<screen>
<userinput>export PATH=[<emphasis class="italic">path to Evergreen</emphasis>]/Open-ILS/src/extras/import: \
/[<emphasis class="italic">path to migration-tools</emphasis>]/migration-tools:$PATH:.
export PERL5LIB=/openils/lib/perl5: \ 
/[<emphasis class="italic">path to migration-tools</emphasis>/Equinox-Migration/lib
</userinput>
</screen>
</step>
<step>
				<para>Dump marc records into MARCXML using <systemitem>yaz-marcdump</systemitem></para>

<screen>
<userinput>
<![CDATA[
echo '<?xml version="1.0" encoding="UTF-8" ?>' > imported_marc_records.xml
yaz-marcdump -f MARC-8 -t UTF-8 -o marcxml imported_marc_records.mrc >> imported_marc_records.xml
]]>
</userinput>
</screen>
</step>	
<step>
				<para>Test validity of XML file using <systemitem>xmllint</systemitem></para>
<screen>

<userinput>
<![CDATA[
 xmllint --noout imported_marc_records.xml 2> marc.xml.err
]]>
</userinput>
</screen>
</step>	

<step>
				<para>Clean up the marc xml file using the <systemitem>marc_cleanup</systemitem> utility:</para>
<screen>
<userinput>
marc_cleanup --marcfile=imported_marc_records.xml --fullauto [--renumber-from #] -ot 001
</userinput>	
</screen>
				<para>The <option>--renumber-from</option> is required if you have bibliographic records already in your system. Use this to set the starting id number higher 
				then the last id in the biblio.record_entry table. The marc_cleanup command will generate a file called <filename>clean.marc.xml</filename></para>
</step>
<step>
				<para>Create a fingerprinter file using the <systemitem>fingerprinter</systemitem> utility:</para>
<screen>
<userinput>
fingerprinter -o incumbent.fp -x incumbent.ex clean.marc.xml
</userinput>			
</screen>
				<para><systemitem>fingerprinter</systemitem> is used for deduplification of the incumbent records. The <option>-o</option> option specifies the 
				output file and the <option>-x</option> option is used to specify the error output file.</para>
</step>
<step>
				<para>Create a fingerprinter file for existing Evergreen bibliographic records using the <systemitem>fingerprinter</systemitem> utility if you 
				have existing bibliographic records in your system previously imported:</para>
<screen>
<userinput>
fingerprinter -o production.fp -x production.fp.ex --marctype=MARC21 existing_marc_records.mrc \
--tag=901 --subfield=c
</userinput>
</screen>
				<para><systemitem>fingerprinter</systemitem> is used for deduplification of the incumbant records.</para>
</step>

<step>
				<para>Create a merged fingerprint file removing duplicate records.</para>
<screen>
<userinput>
cat cat production.fp incumbent.fp | sort -r > dedupe.fp
match_fingerprints [-t start id] -o records.merge dedupe.fp
</userinput>
</screen>
</step>

<step>
				<para>Create a new import XML file using the <systemitem>extract_loadset</systemitem> utility</para>
<screen>
<userinput>extract_loadset -l 1 -i clean.marc.xml -o merged.xml records.merge</userinput>
</screen>
</step>

<step>
				<para>Extract all of the currently used TCN's an generate the .bre and .ingest files to prepare for the bibliographic record load.</para>
<screen>
<userinput>
psql -U evergreen -c "select tcn_value from biblio.record_entry where not deleted" \
| perl -npe 's/^\s+//;' > used_tcns
marc2bre.pl --idfield 903 [--startid=#] --marctype=XML -f final.xml \
--used_tcn_file=used_tcns > evergreen_bre_import_file.bre
</userinput>
</screen>
				<note>
					<para> The option <option>--startid</option> needs to match the start id used in earlier steps and must be higher than largest id value 
					in the biblio.record_entry table. the option <option>--idfield</option> should match the marc datafield used to store your records ids.</para>
				</note>
</step>

<step>
				<para>Ingest the bibliographic records into the Evergreen database.</para>
<screen>
<userinput>
<![CDATA[
parallel_pg_loader.pl \
-or bre \
-or mrd \
-or mfr \
-or mtfe \
-or mafe \
-or msfe \
-or mkfe \
-or msefe \
-a mrd \
-a mfr \
-a mtfe \
-a mafe \
-a msfe \
-a mkfe \
-a msefe evergreen_bre_import_file.bre > bibrecords.sql
]]>
</userinput>
</screen>
			</step>
			<step>
				<para>Load the records using psql and the sql scripts generated from the previous step.</para>
<screen>
<userinput>
<![CDATA[
psql -U evergreen -h localhost -d evergreen -f bibrecords.sql
psql -U evergreen < ~/Ever*/Open-ILS/src/extras/import/quick_metarecord_map.sql > log.create_metabib
]]>
</userinput>
</screen>
			</step>
			<step>
				<para>Extract holdings from marc records for importing copies into Evergreen using the <systemitem>extract_holdings</systemitem> utility.</para>
<screen>
<userinput>
extract_holdings --marcfile=clean.marc.xml --holding 999 --copyid 999i --map holdings.map
</userinput>
</screen>
				<para>This command would extract holdings based on the 949 datafield in the marc records. The copy id is generated from the subfile i in the 999 datafield. You may 
				need to adjust these options based on the field used for holdings informatiom in your marc records.</para>
				<para>The <option>map</option> option <filename>holdings.map</filename> refers to a file to be used for mapping subfields to the holdings data you would like extracted. Here is an example based on mapping holdings data to the 999 data field:</para>
<programlisting>
<![CDATA[
callnum 999 a
barcode 999 i
location 999 l
owning_lib 999 m
circ_modifier 999 t
]]>
</programlisting>
				<para>Running the extract holdings script should produce an sql script <filename>HOLDINGS.pg</filename> similar to:</para>
<programlisting language="sql">
BEGIN;

egid, hseq, l_callnum, l_barcode, l_location, l_owning_lib, l_circ_modifier,
40      0       HD3616.K853 U54 1997    30731100751928  STACKS  FENNELL BOOK
41      1       HV6548.C3 S984 1998     30731100826613  STACKS  FENNELL BOOK
41      2       HV6548.C3 S984 1998     30731100804958  STACKS  BRANTFORD       BOOK
...
</programlisting>
  
				<para>Edit the holdings.pg sql script like so:</para> 
<programlisting language="sql">
BEGIN;

<emphasis class="bold">TRUNCATE TABLE staging_items;</emphasis>

<emphasis class="bold">INSERT INTO staging_items (</emphasis>egid, hseq, l_callnum, l_barcode, l_location, 
l_owning_lib, l_circ_modifier) <emphasis>FROM stdin;</emphasis> 
40      0       HD3616.K853 U54 1997    30731100751928  STACKS  FENNELL BOOK
41      1       HV6548.C3 S984 1998     30731100826613  STACKS  FENNELL BOOK
41      2       HV6548.C3 S984 1998     30731100804958  STACKS  BRANTFORD       BOOK
<emphasis>\.

COMMIT;</emphasis>
</programlisting>
			<para>This file can be used for importing holdings into Evergreen. the <database class="field">egid</database> is a critical column. It is used to link the volume and 
				copy to the bibliographic record. Please refer to <link linkend="migratingbibrecordcopies">for the steps to import your holdings into Evergreen.</link></para> 
			</step>
		</procedure>
		
	</section>
	<section xml:id="migratingbibrecordcopies">
		<title>Adding Copies to Bibliographic Records</title><indexterm><primary>migrating</primary><secondary>holdings</secondary></indexterm>	
		<para>Before bibliographic records can be found in an OPAC search copies will need to be created.  It is very important to understand how various tables related to each other in regards 
		to holdings maintenance.</para> 
		<para>The following procedure will guide you through the process of populating Evergreen with volumes and copies. This is a very simple example. The SQL queries may need to be adjusted 
		for the specific data in your holdings.</para>  
		<procedure>
			<step>
				<para>Create a staging_items staging table to hold the holdings data:</para>
<programlisting language="sql">
CREATE TABLE staging_items (
        l_callnum text, -- call number label
	hseq int, 
        egid  int,  -- biblio.record_entry_id
        createdate      date,
        l_location        text,
        l_barcode         text,
        l_circ_modifier   text,
        l_owning_lib      text  -- actor.org_unit.shortname
);
</programlisting>
			</step>	
			<step>
				<para>Import the items using the HOLDINGS.pg SQL script created using the extract_holdings utility.</para>
<screen>
<userinput>psql -U evergreen -f HOLDINGS.pg evergreen</userinput>
</screen>
				<para>the file <filename>HOLDINGS.pg</filename> and/or the COPY query may need to be adjusted for your particular circumstances.</para>  
			</step>
			

			<step>
				<para>Generate shelving locations from your staging table.</para>
<programlisting language="sql">
INSERT INTO asset.copy_location (name, owning_lib)
SELECT  DISTINCT l.location, ou.id
FROM  staging_items l 
       JOIN actor.org_unit ou	ON (l.owning_lib = ou.shortname); 
</programlisting>
			</step>
			<step>
				<para>Generate circulation modifiers from your staging table.</para>
<programlisting language="sql">
INSERT INTO config.circ_modifier (code, name, description, sip2_media_type, magnetic_media)
        SELECT  DISTINCT l_circ_modifier AS code,
          l_circ_modifier AS name,
          LOWER(l_circ_modifier) AS description,
          '001' AS sip2_media_type,
          FALSE AS magnetic_media
          FROM  staging_items
          WHERE l_circ_modifier NOT IN (SELECT code FROM config.circ_modifier);
</programlisting>
			</step>
			<step>
				<para>Generate call numbers from your staging table:</para>
<programlisting language="sql">
INSERT INTO asset.call_number (creator,editor,record,label,owning_lib)
SELECT  DISTINCT 1, 1, egid, l.callnum, ou.id
FROM  staging.staging_items l
JOIN actor.org_unit ou ON (l.owning_lib = ou.shortname);
</programlisting>
			</step>
			<step>
				<para>Generate copies from your staging table:</para>
<programlisting language="sql">
INSERT INTO asset.copy (
circ_lib, creator, editor, create_date, barcode,
STATUS, location, loan_duration, fine_level, circ_modifier, deposit, ref, call_number)		

SELECT  DISTINCT ou.id AS circ_lib,
	1 AS creator,
	1 AS editor,
	l.l_createdate AS create_date,
	l.l_barcode AS barcode,
	0 AS STATUS,
	cl.id AS location,
	2 AS loan_duration,
	2 AS fine_level,
	l.l_circ_modifier AS circ_modifier,
	FALSE AS deposit,
	CASE
	WHEN l.l_circ_modifier = 'REFERENCE' THEN TRUE
	ELSE FALSE
	END AS ref,						
	cn.id AS call_number
	FROM  staging_items l
		JOIN actor.org_unit ou
			ON (l.l_owning_lib = ou.shortname)
		JOIN asset.copy_location cl
			ON (ou.id = cl.owning_lib AND l.l_location = cl.name)
		JOIN metabib.real_full_rec m 
			ON (m.record = l.egid)
		JOIN asset.call_number cn
			ON (ou.id = cn.owning_lib  
			AND m.record = cn.record       
			AND l.l_callnum = cn.label)      
</programlisting>
				<para>You should now have copies in your Evergreen database and should be able to search and find the bibliographic records with attached copies.</para> 
			</step>
		</procedure>
	</section>
	<section xml:id="migratingpatrons">
		<title>Migrating Patron Data</title>
		<indexterm><primary>migrating</primary><secondary>patrons</secondary></indexterm>
		<para>
		This section will explain the task of migrating your patron data from comma delimited files<indexterm><primary>comma delimited files</primary></indexterm> into Evergreen. 
		It does not deal with the process of exporting from the non-Evergreen 
		system since this process may vary depending on where you are extracting your patron records. Patron could come from an ILS or it could come from a student database in the case of 
		academic records.  		
		</para>
		<para>When importing records into Evergreen you will need to populate 3 tables in your Evergreen database:</para>
		<itemizedlist>
			<listitem><link linkend="actor.table.usr">actor.usr</link> - The main table for user data</listitem>
			<listitem><link linkend="actor.table.card">actor.card</link> - Stores the barcode for users; Users can have more than 1 card but only 1 can be active at a given time;</listitem>
			<listitem><link linkend="actor.table.usr-address">actor.usr_address</link> - Used for storing address information; A user can have more than one address.</listitem>
		</itemizedlist>
		<para>Before following the procedures below to import patron data into Evergreen, it is a good idea to examine the fields in these tables in order to decide on a strategy 
		for data to include 
		in your import. It is important to understand the data types and constraints on each field.</para>
		<procedure>
			<step>
				<para>Export the patron data from your existing ILS or from another source into a comma delimited file. The comma delimited file used for importing
				 the records should use Unicode (UTF8) <indexterm><primary>Unicode</primary></indexterm> character encoding.</para>
			</step>
			<step>
				<para>Create a staging table.<indexterm><primary>staging table</primary></indexterm>  A staging table will allow you to tweak the data before importing. 
				Here is an example sql statement:</para>
<indexterm><primary>sql</primary></indexterm> 
<programlisting language="sql">
CREATE TABLE students (
	 student_id int, barcode text, last_name text, first_name text, email text, address_type text, street1 text, street2 text, 
	city text, province text, country text, postal_code text, phone text, profile int DEFAULT 2, 
	ident_type int, home_ou int, claims_returned_count int DEFAULT 0, usrname text, 
	net_access_level int DEFAULT 2, password text
); 
</programlisting>
				<para>Note the <varname>DEFAULT</varname> variables. These allow you to set default for your library or to populate required fields if you 
				data allows <systemitem>NULL</systemitem> values where fields are required in Evergreen.</para>
				<para>The data field <database class="field">profile</database> in the above SQL script refers to the user group and should be an
				integer referencing the <database class="field">id</database> field in <link linkend="permission.table.grp-tree">
				<database class="table">permission.grp_tree</database></link>. 
				Setting this value will effect the permissions for the user. See the values in <database class="table">permission.grp_tree</database> for 
				possibilities.</para> 
				<para> <database class="field">ident_type</database> is the identification type used for identiying users. This is a integer value referencing 
				<database class="table">config.identification_type</database> and should match the id values of that table. The default values are 
				<literal>1</literal> for Drivers License, <literal>2</literal> for SSN or <literal>3</literal> for other.</para>
				<para><database class="field">home_ou</database> is the home organizational unit for the user. This value needs to match the corresponding 
				<database class="field">id</database> in the <link linkend="actor.table.org-unit"><database class="table">actor.org_unit</database></link> 
				table.</para>    
			</step>
			<step>
				<para>Copy records into staging table from a comma delimited file.</para>
<programlisting language="sql">
COPY students (student_id, last_name, first_name, email, address_type, street1, street2, city, province, country, postal_code, phone) 
	FROM '/home/opensrf/patrons.csv' 
		WITH CSV HEADER;  
</programlisting>
				<para>The above script wil vary depending on the format of your patron load file (<filename>patrons.csv</filename>). You may want to review 
				<link xl:href="http://www.postgresql.org/docs/9.0/static/sql-copy.html" xl:title="PostgreSQL - COPY">PostgreSQL documentation</link></para>  
			</step>
			<step>
				<para>Formatting of some fields to fit Evergreen filed formatting may be required. Here is an example of sql to adjust phone numbers in the staging 
				table to fit the evergreen field:</para>
<programlisting language="sql">
UPDATE students phone = replace(replace(replace(rpad(substring(phone from 1 for 9), 10, '-') || 
substring(phone from 10), '(', ''), ')', ''), ' ', '-');
</programlisting>
				<para>Data <quote>massaging</quote> will be required to fit formats used in Evergreen.</para>
			</step>
			<step>
				<para>Insert records from the staging table into the <link linkend="actor.table.usr"><database class="table">actor.usr</database> </link> Evergreen table:</para>
<programlisting language="sql">
 INSERT INTO actor.usr (
	profile, usrname, email, passwd, ident_type, ident_value, first_given_name, 
	family_name, day_phone, home_ou, claims_returned_count, net_access_level) 
	SELECT profile, students.usrname, email, password, ident_type, student_id, 
	first_name, last_name, phone, home_ou, claims_returned_count, net_access_level 
	FROM students;
</programlisting>		
			</step>
			<step>
				<para>insert records into <link linkend="actor.table.card"><database class="table">actor.card </database></link> from <link linkend="actor.table.usr">
				<database class="table">actor.usr </database></link>.</para>
<programlisting language="sql">
INSERT INTO actor.card (usr, barcode) 
	SELECT actor.usr.id, students.barcode 
	FROM students 
		INNER JOIN actor.usr 
			ON students.usrname = actor.usr.usrname;
</programlisting>		
				<para>This assumes a one to one card patron relationship. If your patron data import has multiple cards assigned to one patron more complex import scripts may be required 					which look for inactive or active flags.</para>	
			</step>
			<step>
				<para>Update actor.usr.card field with actor.card.id to associate active card with the user:</para>
<programlisting language="sql">
UPDATE actor.usr 
	SET card = actor.card.id 
	FROM actor.card 
	WHERE actor.card.usr = actor.usr.id;
</programlisting>			
			</step>
			<step>
				<para>Insert records into <link linkend="actor.table.usr-address">actor.usr_address</link> to add address information for users:</para>
<programlisting language="sql">
INSERT INTO actor.usr_address (usr, street1, street2, city, state, country, post_code) 
	SELECT actor.usr.id, students.street1, students.street2, students.city, students.province, 
	students.country, students.postal_code 
	FROM students 
	INNER JOIN actor.usr ON students.usrname = actor.usr.usrname;
</programlisting>			
			</step>
			<step>
				<para>update <link linkend="actor.table.usr-address">actor.usr.address</link> with address id from address table.</para>
<programlisting language="sql">
UPDATE actor.usr 
	SET mailing_address = actor.usr_address.id, billing_address = actor.usr_address.id 
	FROM actor.usr_address 
	WHERE actor.usr.id = actor.usr_address.usr;
</programlisting>	
			<para>This assumes 1 address per patron. More complex scenarios may require more sophisticated SQL.</para>		
			</step>
		</procedure>
		<simplesect>
			<title>Creating an sql Script for Importing Patrons</title>
			<para>The procedure for importing patron can be automated with the help of an sql script. Follow these steps to create an import script:</para>
		
			<procedure>
				<step>
					<para>Create an new file and name it <filename>import.sql</filename></para>

				</step>

				<step>
					<para>Edit the file to look similar to this:</para>
<programlisting>
BEGIN;

-- Create staging table.
CREATE TABLE students (
	student_id int, barcode text, last_name text, first_name text, email text, address_type text, street1 text, street2 text, 
	city text, province text, country text, postal_code text, phone text, profile int, 
	ident_type int, home_ou int, claims_returned_count int DEFAULT 0, usrname text, 
	net_access_level int DEFAULT 2, password text
); 

--Copy records from your import text file
COPY students (student_id, last_name, first_name, email, address_type, street1, street2, city, province, country, postal_code, phone, password) 
	FROM '/home/opensrf/patrons.csv' 
		WITH CSV HEADER;  


--Insert records from the staging table into the actor.usr table.
INSERT INTO actor.usr (
	profile, usrname, email, passwd, ident_type, ident_value, first_given_name, family_name, 
	day_phone, home_ou, claims_returned_count, net_access_level) 
	SELECT profile, students.usrname, email, password, ident_type, student_id, first_name, 
	last_name, phone, home_ou, claims_returned_count, net_access_level FROM students;

--Insert records from the staging table into the actor.usr table.
INSERT INTO actor.card (usr, barcode) 
	SELECT actor.usr.id, students.barcode 
	FROM students 
		INNER JOIN actor.usr 
			ON students.usrname = actor.usr.usrname;

--Update actor.usr.card field with actor.card.id to associate active card with the user:
UPDATE actor.usr 
	SET card = actor.card.id 
	FROM actor.card 
	WHERE actor.card.usr = actor.usr.id;

--INSERT records INTO actor.usr_address from staging table.
INSERT INTO actor.usr_address (usr, street1, street2, city, state, country, post_code) 
	SELECT actor.usr.id, students.street1, students.street2, students.city, students.province, 
	students.country, students.postal_code 
	FROM students 
	INNER JOIN actor.usr ON students.usrname = actor.usr.usrname;


--Update actor.usr mailing address with id from actor.usr_address table.:
UPDATE actor.usr 
	SET mailing_address = actor.usr_address.id, billing_address = actor.usr_address.id 
	FROM actor.usr_address 
	WHERE actor.usr.id = actor.usr_address.usr;

COMMIT;
</programlisting>
					<para>Placing the sql statements between <code>BEGIN;</code> and <code>COMMIT;</code> creates a transaction block so that if any sql statements fail, the 
					entire process is canceled and the database is rolled back to its original state. Lines beginning with <code>--</code> are comments to let you you what 
					each sql statement is doing and are not processed.</para> 
				</step>
			</procedure>
		</simplesect>
		<simplesect>
			<title>Batch Updating Patron Data</title>
			<indexterm><primary>migrating</primary><secondary>batch updating patrons</secondary></indexterm>
			<para>For academic libraries, doing batch updates to add new patrons to the Evergreen database is a critical task. The above procedures and 
			import script can be easily adapted to create an update script for importing new patrons from external databases. If the data import file contains only new patrons, then, 
			the above procedures will work well to insert those patrons. However, if the data load contains all patrons, a second staging table and a procedure to remove existing 				patrons from that second staging table may be required before importing the new patrons. Moreover, additional steps to update address information and perhaps delete 
			inactive patrons may also be desired depending on the requirements of the institution.</para>
			<para>After developing the scripts to import and update patrons have been created, another important task for library staff is to develop an import strategy and schedule 
			which suits the needs of the library. This could be determined by registration dates of your institution in the case of academic libraries. It is important to balance 
			the convenience of patron loads and the cost of processing these loads vs staff adding patrons manually.</para>   
	       </simplesect> 
	</section>
	<section xml:id="emptydatabase">
		<title>Restoring your Evergreen Database to an Empty State</title>
		<para>If you've done a test import of records and you want to quickly get Evergreen back to a pristine state, you can create a clean Evergreen database schema by performing the 
		following:</para>
		<procedure>
			<step> 
<screen>
<userinput>cd ILS/Open-ILS/src/sql/Pg/</userinput>
</screen>
			</step>
			 <step> 
				 <para>Rebuild the database schema:</para>
<screen>
<userinput>./build-db.sh [db-hostname> [db-port] [db-name] [db-user] [db-password] [db-version]</userinput>
</screen>
				<caution><para>This will remove all of your data from the database and restore the default values.</para></caution> 		
			</step>
		</procedure>
	</section>
	<section xml:id="exportingbibrecordsintoMARC">
		<title>Exporting Bibliographic Records into MARC files</title>
		<indexterm><primary>migrating</primary><secondary>exporting bibliographic records</secondary><tertiary>MARC</tertiary></indexterm>
		<para>The following procedure explains how to export Evergreen bibliographic records into MARC files using the <command>marc_export</command> support script. All steps should be 
		performed by the <systemitem class="username">opensrf</systemitem>  user from your Evergreen server.</para>
		<procedure>
			<step> 
				<para>Create a text file list of the Bibliographic record IDs you would like to export from Evergreen. One way to do this is using SQL:</para>
<programlisting language="sql">
SELECT DISTINCT bre.id FROM biblio.record_entry AS bre
	JOIN asset.call_number AS acn ON acn.record = bre.id 
	WHERE bre.deleted='false' and owning_lib=101 \g /home/opensrf/records.txt;
</programlisting>
				<para>This query creates a file called <filename>records.txt</filename> containing a column of distinct IDs of items owned by the organizational unit with the 
				<database class="field">id</database> <literal>101</literal>.</para>
			</step>
			<step>
				<para>Navigate to the support-scripts folder</para>
<screen>
<userinput>cd /home/opensrf/Evergreen-ILS*/Open-ILS/src/support-scripts/</userinput>
</screen>
			</step>
			<step>
				<para>Run <command>marc_export</command>, using the ID file you created in step 1 to define which files to export.</para>
<screen>
<userinput>cat /home/opensrf/records.txt | ./marc_export -i -c /openils/conf/opensrf_core.xml \
-x /openils/conf/fm_IDL.xml -f XML --timeout 5 > exported_files.xml
</userinput>
</screen>
				<para>The example above exports the records into MARCXML format.</para>
				<note>
				<para>For help or for more options when running <command>marc_export</command>, run <command>marc_export</command> with the <option>-h</option> option:</para>
<screen>
<userinput>./marc_export -h</userinput>
</screen>
				</note>
				
			</step>
				<note>
				<para>Processing time for exporting records depends on several factors such as the number of records you are exporting. It is recommended that you divide the 
				export ID files (<filename>records.txt</filename>) into a manageable number of records if you are exporting a large number of records.</para> 
				</note>
		</procedure>
	</section>	
	<section xml:id="importingauthorityrecords">
		<title>Importing Authority Records</title>
		<indexterm><primary>migrating</primary><secondary>importing authority records</secondary></indexterm>
		<para>The following procedure explains how to export Evergreen bibliographic records into MARC files using the marc_export support script. All steps should be performed by the 
		<systemitem class="username">opensrf</systemitem> user from your Evergreen server.</para>
		<simplesect>
			<title>Importing Authority Records from Command Line</title>
			<para>The major advantages of the command line approach are its speed and its convenience for system administrators who can perform bulk loads of authority records in a 
			controlled environment.</para>		
			<procedure>

				<step> 
					<para>Run <command>marc2are.pl</command> against the authority records, specifying the user name, password, MARC type (USMARC or XML). Use 
					<varname>STDOUT</varname> redirection 
					to either pipe the output directly into the next command or into an output file for inspection. For example, to process a file with authority records in MARCXML format
					named <filename>auth_small.xml</filename> using the default user name and password, and directing the output into a file named <filename>auth.are</filename>:</para>
<screen>
<userinput>cd Open-ILS/src/extras/import/</userinput>
<userinput>perl marc2are.pl --user admin --pass open-ils --marctype XML auth_small.xml > auth.are</userinput>
</screen>
				<note><para>The MARC type will default to USMARC if the <option>--marctype</option> option is not specified.</para></note>
				</step>
				<step> 
					<para>Run <command>pg_loader.pl</command> to generate the SQL necessary for importing the authority records into your system. To save time for very large batches of records, you could 
					simply pipe the output of <command>marc2are.pl</command> directly into <command>pg_loader.pl</command>.</para>
<screen>
<userinput>cd Open-ILS/src/extras/import/</userinput>
<userinput> perl pg_loader.pl --auto are --order are auth.are > auth_load.sql</userinput>
</screen>
				
				</step>
				<step> 
					<para>Load the authority records from the SQL file that you generated in the last step into your Evergreen database using the psql tool. Assuming the default user 
					name, host name, and database name for an Evergreen instance, that command looks like:</para>
<screen>
<userinput>psql -U evergreen -h localhost -d evergreen -f auth_load.sql</userinput>
</screen>
				
				</step>
			</procedure>
		</simplesect>
		<simplesect>
			<title>Importing authority records using the MARC Batch Import/Export interface from the Staff Client</title>
			<para>Good for loading batches of up to 5,000 records (roughly) at a time, the major advantages to importing authority records using the MARC Batch Import/Export interface are 
			that it does not require command-line or direct database access – good for both security in that it minimizes the number of people who need this access and for spreading the 
			effort around to others in the library – and it does most of the work (for example, figuring out whether the batch of records is in XML or USMARC format) for you.</para> 
			<para>To import a set of MARC authority records from the MARC Batch Import/Export interface:</para>
			<procedure>
				<step> 
					<para>From the Evergreen staff client, select <menuchoice><guimenu>Cataloging</guimenu><guimenuitem>MARC Batch Import/Export</guimenuitem></menuchoice>. 
					The <guilabel>Evergreen MARC File Upload</guilabel> screen opens, with <guilabel>Import Records</guilabel> as the highlighted tab.</para>
				</step>
				<step> 
					<para>From the <guimenu>Bibliographic records</guimenu> drop-down menu, select <guimenuitem>Authority records</guimenuitem>.</para>
				
				</step>
				<step> 
					<para>Enter a name for the queue (batch import job) in the <guilabel>Create a new upload queue</guilabel> field.</para>
				
				</step>
				<step> 
					<para>Select the <guilabel>Auto-Import Non-Colliding Records</guilabel> checkbox.</para>
				
				</step>
				<step> 
					<para>Click the <guibutton>Browse…</guibutton> button to select the file of MARC authorities to import.</para>
				
				</step>
				<step> 
					<para>Click the <guibutton>Upload</guibutton> button to begin importing the records. The screen displays <guilabel>Uploading…</guilabel>
					<guilabel>Processing…</guilabel> to show that the records are being transferred to the server, then displays a progress bar to show the actual import 
					progress. When the staff client displays the progress bar, you can disconnect your staff client safely. Very large batches of records might time out at this 
					stage.</para>
				
				</step>
				<step> 
					<para>Once the import is finished, the staff client displays the results of the import process. You can manually display the import progress by selecting 
					the <guilabel>Inspect Queue</guilabel> tab of the MARC Batch Import/Export interface and selecting the queue name. By default, the staff client does not 
					display records that were imported successfully; it only shows records that conflicted with existing entries in the database. The screen shows the overall 
					status of the import process in the top right-hand corner, with the <guilabel>Total</guilabel> and <guilabel>Imported</guilabel> number of records for the 
					queue.</para>
				</step>
			</procedure>

		</simplesect>

	</section>
</chapter>
   
      


 


